import {
	read,
	write,
	parent_dir,
	resolve_dir
} from "computer";
import {
	Type,
	List
} from "zed";
import Program from "termite";

const parse_selects = selects => {
	selects = selects.split(',')
				.map(x => x.trim())
				.map(x => x.split(' as ').map(x => x.trim()));
	return [
		selects
			.map(([name, alias]) => `${alias || name}`)
			.join(','),
		selects
			.filter(([name, alias]) => alias)
			.map(([name, alias]) => `${alias}:mod.exports.${name}`)
			.join(',')
	];
}

export class Replacer extends Type({
	regex: RegExp,
	replacer: Function
}) {
	constructor(regex, replacer) {
		this.regex = regex;
		this.replacer = replacer;
	}
};

const IMPORT_CHECKS = [
	[
		/^import\s+"(\S+)"/,
		(match, uri) => `module.import("${uri}")`
	],
	[
		/^(await\s+)?import\s*\(\s*"([\S^"]+)"\s*\)/,
		(match, async, uri) => `module.import("${uri}")`
	],
	// TODO: require("")
	// [
	// 	/^import\s+\*\s+as\s+(\S+)\s+from\s+"(\S+)"/,
	// 	(match, name, uri) => `const ${name} = module.import("${uri}").exports`
	// ],
	[
		/^import\s+(\S+)\s*,\s*\*\s+as\s+(\S+)\s+from\s+"(\S+)"/,
		(match, std = '', name, uri) =>
`const [${std && `${std},`}${name}] = (mod => [${std && 'mod.default,'}mod.exports])(module.import("${uri}"))`
	],
	[
		/^import\s+((\S+)\s*,\s*)?{(.+)}\s+from\s+"(\S+)"/,
		(match, match2, std = '', selects, uri) => {
			const [imports, aliases] = parse_selects(selects);
			return `const [${std && `${std},`}{${imports}}] = (mod => [${std && 'mod.default,'}{...mod.exports,${aliases}}])(module.import("${uri}"))`;
		}
	],
	// [
	// 	/^import\s+(\S+)\s*,\s*{(.+)}\s+from\s+"(\S+)"/,
	// 	(match, std, selects, uri) => {
	// 		return `const [${std},${}]`
	// 	}
	// ],
	[
		/^import\s+(\S+)\s+from\s+"(\S+)"/,
		(match, std, uri) => `const ${std} = module.import("${uri}").default`
	]
].map(([regex, replacer]) => new Replacer(regex, replacer));

const EXPORT_CHECKS = [
	[
		/export\s+(var|let|const|function|class)\s+(\S+)\s*(=|{)/,
		(match, type, name, end) => {
			// If type is function or class, we need to do some extra work...
			//	(just an extra assign statement I believe... and changing type to be "let/const"
			//	depending whether or not its a function or a class.) We gotta do somethg funky with end too I think.... HMMMMMM
			return `${type} ${name} = module.exports.${name} ${end}`;
		},
// => var bean = module.exports.bean = ...

		/export let that = "that"/,
// => let that = module.exports.that = ...

		/export const thing = "thing"/,
// => const thing = module.exports.thing = ...

// *
		/export function boobs() {}/,
// let boobs = module.exports.boobs = function boobs...

		/export class Woman extends Object {}/,
// let Woman = module.exports.Woman = class Woman extends Object {...

// export default "yo" // <- don't think we gotta do anything. Take at face value.
// module.default = ...

		/export default class Wife extends Woman {}/,
// let Wife = module.default = class Wife extends Woman {...
	]
]

export class Module extends Type({
	path: String, // Where this module lives
	source: String, // source code of the module
	imports: List(Module), // the other Modules this Module depends upon (not flat)
}) {
	constructor(uri) {
		const path = this.path = parent_dir(uri);
		const source = this.source = read(uri);

		

		// basically, go through each import, and make a list of shit we need...

		// We now have the source code we can parse through...

		// i)	import "<FILE>"; <-- we look for this first and it's the easiest
		//			--> extract the value <file> and then
		//				modify => module.import("<entry_relative_path>")
		// ii)	import <DEFAULT> from "<FILE>"
		// iii)	import * as <A> from "<FILE>"
		// iv)	import { <A>, <B> as <C> } from "<FILE>" // <- a touch tricky?
		// v)	import 
	}
}

const render_bundle = () => {
	return `
// Generated by YAB (Yet Another Bundler) on ${new Date().toLocaleString().replace(', ', ' @ ')}
(modules => {

})(new Proxy({
	// render modules here!
}));
`;
}

export default Program({
	["@default"]() {
		this.pass("help");
	},
	build(entry_file = './index.js', output_file = './dist/build.js') {
		// What is our root?
		const ROOT = parent_dir(entry_file);
		const MODULES = `${ROOT}/node_modules`;
		const IMPORTS = {}; // stache our crap here...

		// We now need some recursive functions...
		// this is so we can crawl each node... hmm okay this will take shape soon!


		write(output_file, render_bundle(IMPORTS, resolve_dir(ROOT, entry_file)));
	},
	watch(entry_file, output_file) {
		// use nodejs to watch changes to all the IMPORTS...
		// when a change is detected, re-run detection of IMPORTS
		// and build. Any new files will be added to watchlist and
		// any removed files will be removed from the watchlist...
		// except for stuff in the node_modules/ directory.
		// that shit will be ignored.
	},
	help(cmd) {
		// do stuff..
		if (cmd) {
			// Help for a specific cmd
		} else {
			// general help. I guess.
		}
	}
});